
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ludo Board</title>
    <link rel="stylesheet" href="ludostyle.css">
</head>
<body>
    <h1 class="heading">-:LUDO BOARD:-</h1>

    <!-- Player and Difficulty Selectors -->
    <div style="text-align:center; margin: 20px;">
        <label for="numPlayers">Number of Players: </label>
        <select id="numPlayers">
            <option value="1">1</option>
            <option value="2" selected>2</option>
            <option value="3">3</option>
            <option value="4">4</option>
        </select>
        &nbsp;&nbsp;&nbsp;
        <label for="difficulty">Select Difficulty: </label>
        <select id="difficulty">
            <option value="easy">Easy</option>
            <option value="medium" selected>Medium</option>
            <option value="hard">Hard</option>
        </select>
    </div>

    <!-- Current Turn -->
    <div id="turnDisplay" style="text-align:center; font-size:20px; margin-bottom:10px;">Current Turn: Player 1</div>

    <div class="game">
        <div class="house green">
            <div class="box">
                <div class="square square-one green"></div>
                <div class="square square-two green"></div>
                <div class="square square-three green"></div>
                <div class="square square-four green"></div>
            </div>
        </div>
        <div class="house yellow" style="right: 0">
            <div class="box">
                <div class="square square-one yellow"></div>
                <div class="square square-two yellow"></div>
                <div class="square square-three yellow"></div>
                <div class="square square-four yellow"></div>
            </div>
        </div>
        <div class="house red" style="bottom: 0">
            <div class="box">
                <div class="square square-one red"></div>
                <div class="square square-two red"></div>
                <div class="square square-three red"></div>
                <div class="square square-four red"></div>
            </div>
        </div>
        <div class="house blue" style="bottom: 0;right: 0">
            <div class="box">
                <div class="square square-one blue"></div>
                <div class="square square-two blue"></div>
                <div class="square square-three blue"></div>
                <div class="square square-four blue"></div>
            </div>
        </div>
    </div>

    <!-- Question & Dice Result Display -->
    <div id="questionBox" style="display:none; text-align:center; margin-top: 20px;"></div>
    <div id="diceResult" style="text-align:center; font-size: 24px; margin-top: 10px;"></div>

    <script>
    let questions = [];
    let startTime;
    let humanPlayerQuestionStartTime;
    let humanPlayerCorrectAnswers = 0;
    let humanPlayerTotalQuestions = 0;
    let playerColorMapping = {};
    const defaultColors = ['green', 'yellow', 'red', 'blue']; // Standard Ludo color order
    const diagonalPairs = {
        'green': 'red',
        'yellow': 'blue',
        'red': 'green',
        'blue': 'yellow'
    };
    let currentPlayer = 1;
    let totalPlayers = 2;

    function capitalizeFirstLetter(string) {
        if (!string) return ''; // Handle empty or null strings
        return string.charAt(0).toUpperCase() + string.slice(1);
    }

    fetch('questions.csv')
        .then(response => response.text())
        .then(csv => {
            const lines = csv.trim().split('\n').slice(1);
            questions = lines.map(line => {
                const [difficulty, question, A, B, C, D, answer] = line.split(',');
                return { difficulty, question, A, B, C, D, answer: answer.trim() };
            });
        });

    function setupPlayerColors() {
        // totalPlayers is the global variable reflecting the user's selection
        // from the numPlayers dropdown (1, 2, 3, or 4).
        // It's assumed to be up-to-date when this function is called.
        playerColorMapping = {}; // Reset previous mapping

        if (totalPlayers === 1 || totalPlayers === 2) {
            // Player 1 (Human) gets the first default color.
            const player1Color = defaultColors[0]; // e.g., green
            // Player 2 (Bot or Human) gets the diagonally opposite color.
            const player2Color = diagonalPairs[player1Color]; // e.g., red

            playerColorMapping[1] = player1Color;
            playerColorMapping[2] = player2Color;
        } else if (totalPlayers === 3) {
            playerColorMapping[1] = defaultColors[0];
            playerColorMapping[2] = defaultColors[1];
            playerColorMapping[3] = defaultColors[2];
        } else { // 4 players (totalPlayers === 4)
            for (let i = 0; i < defaultColors.length; i++) {
                playerColorMapping[i + 1] = defaultColors[i];
            }
        }
        // Later steps will use this mapping to control pieces and UI.
        // console.log("Player colors set up:", playerColorMapping); // For debugging
    }

    function updateBoardVisualsForPlayerCount() {
        // Get the list of colors that are currently active based on playerColorMapping
        const activeColors = Object.values(playerColorMapping);

        // Iterate over all default Ludo colors
        defaultColors.forEach(color => {
            // Find the house element for the current color (e.g., div with class "house green")
            const houseElement = document.querySelector(`.house.${color}`);

            // It's also good practice to handle pieces if they are separate DOM elements,
            // but for now, we'll focus on the house.
            // Example for pieces:
            // const pieceElements = document.querySelectorAll(`.piece.${color}`);

            if (houseElement) {
                if (activeColors.includes(color)) {
                    // If the color is active, ensure its house is visible
                    houseElement.style.display = 'block';
                    // If pieces were made non-interactive, make them interactive here
                    // pieceElements.forEach(p => p.classList.remove('disabled-piece'));
                } else {
                    // If the color is not active, hide its house
                    houseElement.style.display = 'none';
                    // If pieces exist, disable them too
                    // pieceElements.forEach(p => p.classList.add('disabled-piece'));
                }
            }
        });
        // console.log("Board visuals updated for player count. Active colors:", activeColors); // For debugging
    }

    function showQuestion() {
        const level = document.getElementById("difficulty").value;
        const filtered = questions.filter(q => q.difficulty === level);
        const q = filtered[Math.floor(Math.random() * filtered.length)];
        const isBot = totalPlayers === 1 && currentPlayer === 2;

        if (isBot) {
            const botQuestionViewTime = new Date().getTime();
            let humanSuccessRate = 0.5; // Default if no questions answered yet
            if (humanPlayerTotalQuestions > 0) {
                humanSuccessRate = humanPlayerCorrectAnswers / humanPlayerTotalQuestions;
            }

            let botCorrectChance;
            if (humanSuccessRate > 0.7) { // Player is doing well, bot gets harder
                botCorrectChance = 0.85;
            } else if (humanSuccessRate < 0.4) { // Player is struggling, bot gets easier
                botCorrectChance = 0.35;
            } else { // Medium difficulty
                botCorrectChance = 0.60;
            }

            let botWillBeCorrect = Math.random() < botCorrectChance;
            let botChoice;
            const choices = ['A', 'B', 'C', 'D'];
            const correctAnswerValue = q.answer; // e.g., 'A'

            if (botWillBeCorrect) {
                botChoice = correctAnswerValue;
            } else {
                // Pick a random wrong answer
                let wrongChoices = choices.filter(c => c !== correctAnswerValue);
                botChoice = wrongChoices[Math.floor(Math.random() * wrongChoices.length)];
            }

            // Bot answers after a random delay (3 to 15 seconds)
            // The time taken will affect bot's dice roll via submitAnswer's logic
            const botThinkingTime = Math.floor(Math.random() * 12000) + 3000;

            setTimeout(() => {
                // 'q.answer' is the actual correct answer key, e.g., 'A', 'B' etc.
                submitAnswer(botChoice, correctAnswerValue, botQuestionViewTime);
            }, botThinkingTime);
            return; // Important to return after setting up the bot's delayed answer
        }

        const box = document.getElementById("questionBox");
        box.innerHTML = `
            <p><strong>${q.question}</strong></p>
            <button onclick="submitAnswer('A', '${q.answer}', humanPlayerQuestionStartTime)">${q.A}</button>
            <button onclick="submitAnswer('B', '${q.answer}', humanPlayerQuestionStartTime)">${q.B}</button>
            <button onclick="submitAnswer('C', '${q.answer}', humanPlayerQuestionStartTime)">${q.C}</button>
            <button onclick="submitAnswer('D', '${q.answer}', humanPlayerQuestionStartTime)">${q.D}</button>
        `;
        box.style.display = 'block';
        humanPlayerQuestionStartTime = new Date().getTime();
    }

    function submitAnswer(choice, correctAnswer, questionStartTime) {
        const timeTaken = (new Date().getTime() - questionStartTime) / 1000;
        const box = document.getElementById("questionBox");
        box.style.display = 'none';

        let diceVal;
        if (choice === correctAnswer && timeTaken <= 15) {
            // Roll 1-6
            diceVal = Math.floor(Math.random() * 6) + 1;
        } else {
            // Roll 1-3
            diceVal = Math.floor(Math.random() * 3) + 1;
        }

        document.getElementById("diceResult").innerText = `Player ${currentPlayer} got: ${diceVal}`;

        // Update stats for human player in single player mode
        // Assumes 'currentPlayer' reflects the player who just answered.
        if (totalPlayers === 1 && currentPlayer === 1) {
            humanPlayerTotalQuestions++;
            if (choice === correctAnswer) {
                humanPlayerCorrectAnswers++;
            }
        }
        nextTurn();
    }

    function nextTurn() {
        const numPlayersSelect = document.getElementById("numPlayers");
        totalPlayers = parseInt(numPlayersSelect.value); // User's selection (1, 2, 3, or 4)

        let effectiveNumPlayersForTurnCycle;
        if (totalPlayers === 1) {
            effectiveNumPlayersForTurnCycle = 2; // P1 (Human), P2 (Bot)
        } else {
            effectiveNumPlayersForTurnCycle = totalPlayers; // P1, P2, P3, P4 (all human)
        }

        currentPlayer++;
        if (currentPlayer > effectiveNumPlayersForTurnCycle) {
            currentPlayer = 1;
        }
        const nextPlayerColorName = playerColorMapping[currentPlayer] ? capitalizeFirstLetter(playerColorMapping[currentPlayer]) : '';
        document.getElementById("turnDisplay").innerText = `Current Turn: Player ${currentPlayer} (${nextPlayerColorName})`;

        // Auto trigger for bot. 'totalPlayers' refers to the user's selection of "1 player".
        // 'currentPlayer' is 2 for the bot in a 1-player game.
        if (totalPlayers === 1 && currentPlayer === 2) {
            setTimeout(showQuestion, 1000);
        }
    }

    document.addEventListener('DOMContentLoaded', () => {
        document.body.addEventListener('click', function (e) {
            if (e.target.id === 'dice' || e.target.classList.contains('dice')) {
                showQuestion();
            }
        });

        document.getElementById("numPlayers").addEventListener('change', () => {
            totalPlayers = parseInt(document.getElementById("numPlayers").value);
            currentPlayer = 1;
            // currentPlayer is 1 here
            setupPlayerColors(); // Re-setup colors when player count changes
            updateBoardVisualsForPlayerCount(); // Add this call
            const changedPlayerColorName = playerColorMapping[currentPlayer] ? capitalizeFirstLetter(playerColorMapping[currentPlayer]) : '';
            document.getElementById("turnDisplay").innerText = `Current Turn: Player ${currentPlayer} (${changedPlayerColorName})`;
            // Logic to update UI for non-active players will be in a subsequent step.
        });

        // Initial setup:
        // Ensure totalPlayers reflects the initial state of the numPlayers dropdown value.
        totalPlayers = parseInt(document.getElementById("numPlayers").value);
        setupPlayerColors();
        updateBoardVisualsForPlayerCount(); // Add this call
        // Update turn display for initial load.
        // currentPlayer is initially 1
        const initialPlayerColor = playerColorMapping[currentPlayer] ? capitalizeFirstLetter(playerColorMapping[currentPlayer]) : '';
        document.getElementById("turnDisplay").innerText = `Current Turn: Player ${currentPlayer} (${initialPlayerColor})`;
    });
    </script>

</body>
</html>
