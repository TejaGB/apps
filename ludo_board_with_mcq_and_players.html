
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ludo Board</title>
    <link rel="stylesheet" href="ludostyle.css">
</head>
<body>
    <h1 class="heading">-:LUDO BOARD:-</h1>

    <!-- Player and Difficulty Selectors -->
    <div style="text-align:center; margin: 20px;">
        <label for="numPlayers">Number of Players: </label>
        <select id="numPlayers">
            <option value="1">1</option>
            <option value="2" selected>2</option> <!-- Default player count -->
            <option value="3">3</option>
            <option value="4">4</option>
        </select>
        &nbsp;&nbsp;&nbsp;
        <label for="topicSelection">Select Topic: </label>
        <select id="topicSelection">
            <option value="">Loading Topics...</option>
        </select>
        &nbsp;&nbsp;&nbsp;
        <label for="difficulty">Select Difficulty: </label>
        <select id="difficulty">
            <option value="easy" selected>Easy</option> <!-- Default set to Easy -->
            <option value="medium">Medium</option>
            <option value="hard">Hard</option>
        </select>
    </div>

    <!-- Current Turn -->
    <div id="turnDisplay" style="text-align:center; font-size:20px; margin-bottom:10px;">Current Turn: Player 1</div>

    <div class="game">
        <div class="house green">
            <div class="box">
                <div class="square square-one green"></div>
                <div class="square square-two green"></div>
                <div class="square square-three green"></div>
                <div class="square square-four green"></div>
            </div>
        </div>
        <div class="house yellow" style="right: 0">
            <div class="box">
                <div class="square square-one yellow"></div>
                <div class="square square-two yellow"></div>
                <div class="square square-three yellow"></div>
                <div class="square square-four yellow"></div>
            </div>
        </div>
        <div class="house red" style="bottom: 0">
            <div class="box">
                <div class="square square-one red"></div>
                <div class="square square-two red"></div>
                <div class="square square-three red"></div>
                <div class="square square-four red"></div>
            </div>
        </div>
        <div class="house blue" style="bottom: 0;right: 0">
            <div class="box">
                <div class="square square-one blue"></div>
                <div class="square square-two blue"></div>
                <div class="square square-three blue"></div>
                <div class="square square-four blue"></div>
            </div>
        </div>
    </div>

    <!-- Question & Dice Result Display -->
    <div id="questionBox" style="display:none; text-align:center; margin-top: 20px;"></div>
    <div id="diceResult" style="text-align:center; font-size: 24px; margin-top: 10px;"></div>

    <script>
    let questions = [];
    let availableTopics = [];
    let startTime;
    let humanPlayerQuestionStartTime;
    let humanPlayerCorrectAnswers = 0;
    let humanPlayerTotalQuestions = 0;
    let playerColorMapping = {};
    const defaultColors = ['green', 'yellow', 'red', 'blue']; // Standard Ludo color order
    const diagonalPairs = {
        'green': 'red',
        'yellow': 'blue',
        'red': 'green',
        'blue': 'yellow'
    };
    let currentPlayer = 1;
    let totalPlayers = 2;

    function capitalizeFirstLetter(string) {
        if (!string) return ''; // Handle empty or null strings
        return string.charAt(0).toUpperCase() + string.slice(1);
    }

    fetch('questions.csv')
        .then(response => {
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            return response.text();
        })
        .then(csvText => {
            const lines = csvText.trim().split('\n');
            const header = lines[0].split(',').map(h => h.trim().toLowerCase()); // Process header
            const questionsStartIndex = 1; // Data starts from the second line

            // Dynamically find column indices - more robust
            // For this subtask, we'll stick to the agreed fixed order for simplicity,
            // but a production system might map headers to indices.
            // const topicIndex = header.indexOf('topic');
            // const difficultyIndex = header.indexOf('difficulty');
            // ... etc.

            const uniqueTopics = new Set();
            questions = []; // Reset questions array

            for (let i = questionsStartIndex; i < lines.length; i++) {
                const line = lines[i];
                if (line.trim() === '') continue; // Skip empty lines

                const parts = line.split(',');

                // Assuming fixed order: topic, difficulty, question, A, B, C, D, answer
                if (parts.length < 8) { // Basic validation for enough columns
                    console.warn(`Skipping malformed CSV line: ${line}`);
                    continue;
                }

                const topic = parts[0].trim();
                const difficulty = parts[1].trim();
                const questionText = parts[2].trim(); // Renamed to avoid conflict with global 'question'
                const optA = parts[3].trim();
                const optB = parts[4].trim();
                const optC = parts[5].trim();
                const optD = parts[6].trim();
                const correctAnswer = parts[7].trim();

                if (topic) {
                    uniqueTopics.add(topic);
                }

                questions.push({
                    topic: topic,
                    difficulty: difficulty,
                    question: questionText, // Storing actual question text under 'question' key
                    A: optA,
                    B: optB,
                    C: optC,
                    D: optD,
                    answer: correctAnswer
                });
            }

            availableTopics = Array.from(uniqueTopics).sort();

            // console.log("Questions loaded:", questions.length);
            // console.log("Available topics:", availableTopics);

            if (typeof populateTopicSelector === 'function') {
                populateTopicSelector();
            } else {
                // This case should ideally not happen if functions are defined before use.
                console.error("populateTopicSelector function is not defined when called.");
            }
        })
        .catch(error => {
            console.error("Error fetching or parsing questions.csv:", error);
            // It might be useful to inform the user or disable quiz features if questions can't load.
            document.getElementById("questionBox").innerHTML = "<p>Error loading questions. Please try again later.</p>";
            document.getElementById("questionBox").style.display = "block";
        });

    function setupPlayerColors() {
        // totalPlayers is the global variable reflecting the user's selection
        // from the numPlayers dropdown (1, 2, 3, or 4).
        // It's assumed to be up-to-date when this function is called.
        playerColorMapping = {}; // Reset previous mapping

        if (totalPlayers === 1 || totalPlayers === 2) {
            // Player 1 (Human) gets the first default color.
            const player1Color = defaultColors[0]; // e.g., green
            // Player 2 (Bot or Human) gets the diagonally opposite color.
            const player2Color = diagonalPairs[player1Color]; // e.g., red

            playerColorMapping[1] = player1Color;
            playerColorMapping[2] = player2Color;
        } else if (totalPlayers === 3) {
            playerColorMapping[1] = defaultColors[0];
            playerColorMapping[2] = defaultColors[1];
            playerColorMapping[3] = defaultColors[2];
        } else { // 4 players (totalPlayers === 4)
            for (let i = 0; i < defaultColors.length; i++) {
                playerColorMapping[i + 1] = defaultColors[i];
            }
        }
        // Later steps will use this mapping to control pieces and UI.
        // console.log("Player colors set up:", playerColorMapping); // For debugging
    }

    function updateBoardVisualsForPlayerCount() {
        // Get the list of colors that are currently active based on playerColorMapping
        const activeColors = Object.values(playerColorMapping);

        // Iterate over all default Ludo colors
        defaultColors.forEach(color => {
            // Find the house element for the current color (e.g., div with class "house green")
            const houseElement = document.querySelector(`.house.${color}`);

            // It's also good practice to handle pieces if they are separate DOM elements,
            // but for now, we'll focus on the house.
            // Example for pieces:
            // const pieceElements = document.querySelectorAll(`.piece.${color}`);

            if (houseElement) {
                if (activeColors.includes(color)) {
                    // If the color is active, ensure its house is visible
                    houseElement.style.display = 'block';
                    // If pieces were made non-interactive, make them interactive here
                    // pieceElements.forEach(p => p.classList.remove('disabled-piece'));
                } else {
                    // If the color is not active, hide its house
                    houseElement.style.display = 'none';
                    // If pieces exist, disable them too
                    // pieceElements.forEach(p => p.classList.add('disabled-piece'));
                }
            }
        });
        // console.log("Board visuals updated for player count. Active colors:", activeColors); // For debugging
    }

    function populateTopicSelector() {
        const topicSelector = document.getElementById("topicSelection");
        if (!topicSelector) {
            console.error("Topic selector element not found.");
            return;
        }

        topicSelector.innerHTML = ""; // Clear existing options (e.g., "Loading Topics...")

        if (availableTopics.length === 0) {
            const option = document.createElement("option");
            option.value = "";
            option.textContent = "No Topics Loaded";
            topicSelector.appendChild(option);
            topicSelector.disabled = true; // Disable if no topics
            return;
        }

        topicSelector.disabled = false; // Enable if topics are available
        availableTopics.forEach(topic => {
            const option = document.createElement("option");
            option.value = topic;
            // Assuming topic names from CSV are suitable for display.
            // If capitalization is desired: option.textContent = capitalizeFirstLetter(topic);
            option.textContent = topic;
            topicSelector.appendChild(option);
        });

        // Set default topic selection (e.g., the first topic in the sorted list)
        if (availableTopics.length > 0) {
            topicSelector.value = availableTopics[0];
        }

        // Ensure difficulty is set to Easy by default (already set in HTML via 'selected',
        // but can be reaffirmed here if needed, or if HTML wasn't changed)
        const difficultySelector = document.getElementById("difficulty");
        if (difficultySelector && difficultySelector.value !== "easy") {
             difficultySelector.value = "easy"; // Ensures JS sets it if HTML default fails
        }

        // Any logic that needs to run after selectors are ready can be triggered here.
        // For example, if questions should be immediately filtered or a "start game" button enabled.
    }

function showQuestion() {
    const selectedDifficulty = document.getElementById("difficulty").value;
    const selectedTopic = document.getElementById("topicSelection").value;
    const questionBox = document.getElementById("questionBox"); // Get questionBox once

    // Filter questions by both selected difficulty and topic
    const filteredQuestions = questions.filter(q => {
        // Ensure q.topic and q.difficulty exist to prevent errors if data is malformed
        return q.topic === selectedTopic && q.difficulty === selectedDifficulty;
    });

    if (filteredQuestions.length === 0) {
        questionBox.innerHTML = "<p>No questions available for the selected topic and difficulty. Please change your selections or check the question data.</p>";
        questionBox.style.display = 'block';
        // Clear previous dice result if no question can be shown
        const diceResultDisplay = document.getElementById("diceResult");
        if (diceResultDisplay) {
            diceResultDisplay.innerText = "";
        }
        return; // Exit the function as no question can be displayed
    }

    // Select a random question from the filtered list
    const q = filteredQuestions[Math.floor(Math.random() * filteredQuestions.length)];

    // Bot logic: uses global 'totalPlayers' and 'currentPlayer'
    const isBot = totalPlayers === 1 && currentPlayer === 2;

    if (isBot) {
        const botQuestionViewTime = new Date().getTime();
        let humanSuccessRate = 0.5;
        if (humanPlayerTotalQuestions > 0) {
            humanSuccessRate = humanPlayerCorrectAnswers / humanPlayerTotalQuestions;
        }

        let botCorrectChance;
        if (humanSuccessRate > 0.7) {
            botCorrectChance = 0.85;
        } else if (humanSuccessRate < 0.4) {
            botCorrectChance = 0.35;
        } else {
            botCorrectChance = 0.60;
        }

        let botWillBeCorrect = Math.random() < botCorrectChance;
        let botChoice;
        const choices = ['A', 'B', 'C', 'D'];
        const correctAnswerValue = q.answer;

        if (botWillBeCorrect) {
            botChoice = correctAnswerValue;
        } else {
            let wrongChoices = choices.filter(c => c !== correctAnswerValue);
            // Ensure wrongChoices is not empty (e.g. if q.answer was somehow not A,B,C,D)
            if (wrongChoices.length === 0) wrongChoices = choices.filter(c => c !== choices[0]); // fallback
            if (wrongChoices.length === 0) wrongChoices = ['A']; // ultimate fallback
            botChoice = wrongChoices[Math.floor(Math.random() * wrongChoices.length)];
        }

        const botThinkingTime = Math.floor(Math.random() * 12000) + 3000;

        setTimeout(() => {
            submitAnswer(botChoice, correctAnswerValue, botQuestionViewTime);
        }, botThinkingTime);
        return; // Bot doesn't need HTML question display
    }

    // Human player's turn: display the question
    // Ensure q and its properties (q.question, q.A etc.) are valid
    if (!q || typeof q.question === 'undefined') {
        questionBox.innerHTML = "<p>Selected question is invalid. Please try again.</p>";
        questionBox.style.display = 'block';
        return;
    }

    questionBox.innerHTML = `
        <p><strong>${q.question}</strong></p>
        <button onclick="submitAnswer('A', '${q.answer}', humanPlayerQuestionStartTime)">${q.A}</button>
        <button onclick="submitAnswer('B', '${q.answer}', humanPlayerQuestionStartTime)">${q.B}</button>
        <button onclick="submitAnswer('C', '${q.answer}', humanPlayerQuestionStartTime)">${q.C}</button>
        <button onclick="submitAnswer('D', '${q.answer}', humanPlayerQuestionStartTime)">${q.D}</button>
    `;
    questionBox.style.display = 'block';
    humanPlayerQuestionStartTime = new Date().getTime(); // Record start time for human player
}

    function submitAnswer(choice, correctAnswer, questionStartTime) {
        const timeTaken = (new Date().getTime() - questionStartTime) / 1000;
        const box = document.getElementById("questionBox");
        box.style.display = 'none';

        let diceVal;
        if (choice === correctAnswer && timeTaken <= 15) {
            // Roll 1-6
            diceVal = Math.floor(Math.random() * 6) + 1;
        } else {
            // Roll 1-3
            diceVal = Math.floor(Math.random() * 3) + 1;
        }

        document.getElementById("diceResult").innerText = `Player ${currentPlayer} got: ${diceVal}`;

        // Update stats for human player in single player mode
        // Assumes 'currentPlayer' reflects the player who just answered.
        if (totalPlayers === 1 && currentPlayer === 1) {
            humanPlayerTotalQuestions++;
            if (choice === correctAnswer) {
                humanPlayerCorrectAnswers++;
            }
        }
        nextTurn();
    }

    function nextTurn() {
        const numPlayersSelect = document.getElementById("numPlayers");
        totalPlayers = parseInt(numPlayersSelect.value); // User's selection (1, 2, 3, or 4)

        let effectiveNumPlayersForTurnCycle;
        if (totalPlayers === 1) {
            effectiveNumPlayersForTurnCycle = 2; // P1 (Human), P2 (Bot)
        } else {
            effectiveNumPlayersForTurnCycle = totalPlayers; // P1, P2, P3, P4 (all human)
        }

        currentPlayer++;
        if (currentPlayer > effectiveNumPlayersForTurnCycle) {
            currentPlayer = 1;
        }
        const nextPlayerColorName = playerColorMapping[currentPlayer] ? capitalizeFirstLetter(playerColorMapping[currentPlayer]) : '';
        document.getElementById("turnDisplay").innerText = `Current Turn: Player ${currentPlayer} (${nextPlayerColorName})`;

        // Auto trigger for bot. 'totalPlayers' refers to the user's selection of "1 player".
        // 'currentPlayer' is 2 for the bot in a 1-player game.
        if (totalPlayers === 1 && currentPlayer === 2) {
            setTimeout(showQuestion, 1000);
        }
    }

    document.addEventListener('DOMContentLoaded', () => {
        document.body.addEventListener('click', function (e) {
            if (e.target.id === 'dice' || e.target.classList.contains('dice')) {
                showQuestion();
            }
        });

        document.getElementById("numPlayers").addEventListener('change', () => {
            totalPlayers = parseInt(document.getElementById("numPlayers").value);
            currentPlayer = 1;
            // currentPlayer is 1 here
            setupPlayerColors(); // Re-setup colors when player count changes
            updateBoardVisualsForPlayerCount(); // Add this call
            const changedPlayerColorName = playerColorMapping[currentPlayer] ? capitalizeFirstLetter(playerColorMapping[currentPlayer]) : '';
            document.getElementById("turnDisplay").innerText = `Current Turn: Player ${currentPlayer} (${changedPlayerColorName})`;
            // Logic to update UI for non-active players will be in a subsequent step.
        });

        // Initial setup:
        // Ensure totalPlayers reflects the initial state of the numPlayers dropdown value.
        totalPlayers = parseInt(document.getElementById("numPlayers").value);
        setupPlayerColors();
        updateBoardVisualsForPlayerCount(); // Add this call
        // Update turn display for initial load.
        // currentPlayer is initially 1
        const initialPlayerColor = playerColorMapping[currentPlayer] ? capitalizeFirstLetter(playerColorMapping[currentPlayer]) : '';
        document.getElementById("turnDisplay").innerText = `Current Turn: Player ${currentPlayer} (${initialPlayerColor})`;
    });
    </script>

</body>
</html>
